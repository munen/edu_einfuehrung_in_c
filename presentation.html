<!doctype html>
<html>
<head> 
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>My Slides</title> 
    <link rel="stylesheet" type="text/css" media="screen, projection, print" 
     href="slidy.css" />
    <link rel="stylesheet" type="text/css" media="screen, projection, print" 
     href="style.css" />
    <script src="showdown.js"></script>
    <script src="slidy.js"></script>
    <script src="sh_main.min.js"></script>
    
</head>
<body>
<script type=text/markdown>
<!--


# Einführung in die Programmierung in C

-----------------------------------------------------
# Informationen

### Allgemein

* Alain M. Lafon
* E-Mail: aml@panter.ch
* Folien und Code
 * http://edu.panter.ch/OsEinfuehrungSystemProgrammierung
* Literatur: Kernighan & Ritchie - The C Programming language

### Berufserfahrung

* 1 Jahr Campus Ambassador - Sun Microsystems
* 3 Jahre Python, Ruby, (C#) - Swiss Post Solutions AG
* 1 Jahr Ruby on Rails - Panter LLC


### Besprechung Ablauf


-----------------------------------------------------
# Historische Einbettung

 * Entwickelt zw. 1969 und 1973 von Dennis Ritchie @ Bell Labs
 * K&R C - erste Auflage 1978, zweite Auflage 1988
 * Wurde entwickelt, um Unix portabel zu machen (PDP-7)

-----------------------------------------------------
# Es ist 2011, warum noch C? (1)

* Populäre Sprachen:
 * Java
 * .NET
 * Ruby
 * Python
 * PHP
 * Javascript

-----------------------------------------------------
# Es ist 2011, warum noch C? (2)

* Geschwindigkeit ([Alioth Shootout](http://shootout.alioth.debian.org/u32/which-programming-languages-are-fastest.php?gcc=on&java=on&csharp=on&v8=on&yarv=on&php=on&python3=on&calc=chart))

 ![](images/alioth-shootout.png)

-----------------------------------------------------
# Es ist 2011, warum noch C? (3)

* Nähe zur Hardware
  * Betriebssysteme [Unix/Linux, Windows (C/C++/ASM), OSX(ObjectiveC)]
* Gut für Neueinsteiger:
  * Wenig Syntax
  * Fördert Verständnis
* Implementierung anderer Sprachen
 * CRuby, CPyton, PHP, .NET (C/C++), JS V8 (C++), Sun JVM (C++)
* Neu: Google Chrome Native Client ([NaCl](http://code.google.com/p/nativeclient/))
* Grundlage für C++, ObjC, (Java..)

-----------------------------------------------------
# Hallo Welt
    #include <stdio.h>

    int main() {
      printf("Hallo HSZ-T\n");
    }
hallo\_hszt.c

-----------------------------------------------------
# Hands on!
# System bereit?
 * Compiler
 * Editor

-----------------------------------------------------
# Grad Fahrenheit in Celius (1)

# Erste Lernziele
 * Variable
   * Deklaration / Initialisierung
 * Schleife
 * Bedingung

# Algorithmus zur Umrechnung

( TFahrenheit - 32 ) × 5 / 9


-----------------------------------------------------
# Grad Fahrenheit in Celius (2)

    #include <stdio.h>

    /* print Fahrenheit-Celsius table for fahr = 0, 20, ..., 300 */
    int main() {
      int fahr, celsius;
      int lower, upper, step;

      lower = 0; /* lower limit of temperature scale */ 
      upper = 300; /* upper limit */ 
      step = 20; /* step size */
      
      fahr = lower; 
      while (fahr <= upper) {
        celsius = 5 * (fahr-32) / 9; 
        printf("%d\t%d\n", fahr, celsius); 
        fahr = fahr + step;
      }
    }
fahrenheit2celsius.c

-----------------------------------------------------
# Exkurs Datentypen
<table border="3">
 <tr>
   <td>
    char
   </td>
   <td>
    ein Byte<br>
    (-128 / 128)
   </td>
 </tr>
 <tr>
   <td>
    short
   </td>
   <td>
    short Integer<br>
    (-32,768 / 32,767)
   </td>
 </tr>
 <tr>
   <td>
    int
   </td>
   <td>
    Integer<br>
   (−2,147,483,648 / 2,147,483,647)
   </td>
 </tr>
 <tr>
   <td>
    long
   </td>
   <td>
    long Integer<br>
    32bit: (−2,147,483,648 / 2,147,483,647)<br>
    64bit: (−9,223,372,036,854,775,808 / 9,223,372,036,854,775,807)
   </td>
 </tr>
 <tr>
   <td>
    float
   </td>
   <td>
    floating point<br>
    (≤1E−37 / ≥1E+37))
   </td>
 </tr>
</table>

* Grösse der Datentypen ist abhängig von der Platform
 * limits.h

-----------------------------------------------------
# Zurück zu Fahrenheit2Celsius

* Bisher Berechnung auf Ganzzahlen (Integer)
* Änderung der Berechnung auf Gleitkomma (Float)
 * Deklaration (int -> float)
 * Berechnung und Genauigkeit

<pre>
    celsius = (5.0/9.0) * (fahrenheit-32.0); 
    printf("%3.0f %6.1f\n", fahrenheit, celsius);
</pre>
fahrenheit2celsius\_float.c



-----------------------------------------------------
# For Schleifen

    #include <stdio.h>
    /* print Fahrenheit-Celsius table */

    int main() {
      int fahr;
      for (fahr = 0; fahr <= 300; fahr = fahr + 20)
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
    }
fahrenheit2celsius\_for\_loop.c


Selbes Ergebnis, aber bedeutend weniger Code.

 * Weniger Variable
 * Berechnung jetzt inline in prinft



-----------------------------------------------------
# Konstanten

    #include <stdio.h>
    
    #define LOWER 0
    #define UPPER 300
    #define STEP 20
    
    /* print Fahrenheit-Celsius table */ 
    int main() {
      int fahr;
      for (fahr = LOWER; fahr <= UPPER; fahr = fahr + STEP) 
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
    }

* Besserer Code: Keine 'magic numbers'
* Präprozessor
 * ersetzt Text
* Konstanten != Variable
 * Keine Deklaration



-----------------------------------------------------
# Ein- und Ausgabe(1)

    #include <stdio.h>
    /* count characters in input; 1st version */ 
    
    int main() {
      long nc;
      nc = 0; 
      while (getchar() != EOF)
        nc++;
      printf("%ld\n", nc);
    }
character\_counting_1.c

 * getchar()
 * ++ Operator
  * gleichbedeutend zu nc = nc + 1
  * Präfix und Postfix, ebenso --
 * EOF
 
-----------------------------------------------------
# Ein- und Ausgabe(2)
# Alternative Implementierung

    #include <stdio.h>

    /* count characters in input; 2nd version */ 
    int main() {
      double nc;
      for (nc = 0; getchar() != EOF; ++nc)
        ;
      printf("%.0f\n", nc);
    }
character\_counting\_2.c

Besondere Variante der for-Schleife

 * Kein Code im Rumpf der Schleife
 * Das Semikolon in der Zeile steht für die minimale Anforderung an Rumpf 
   * 'null' Statement
 
-----------------------------------------------------
# Ein- und Ausgabe(3)

    #include <stdio.h>
    
    /* count lines in input */ 
    int main() {
      int c, nl;
    
      nl = 0; 
      while ((c = getchar()) != EOF)
        if (c == '\n') 
          nl++;
      printf("%d\n", nl);
    }
line\_counting.c

* == (Equality Operator)
 * Achtung: = ungleich ==
* Einfache Anführungszeichen ('') bedeuten 'character constants'
 * '\n' (Escape sequence)


-----------------------------------------------------
# Arrays(1)
# Häufigkeitszählung von Ziffern(1)

    #include <stdio.h>
    
    // count digits
    int main() {
      int i, c;
      int ndigit[10];
      
      // Initializing array to count of zero
      for (i = 0; i < 10; ++i)
        ndigit[i] = 0;
    
      // Actual count
      while ((c = getchar()) != EOF)
        if (c >= '0' && c <= '9')
          ++ndigit[c-'0'];
    
      // Print result
      printf("Digits = ");
      for (i = 0; i < 10; ++i)
        printf(" %d", ndigit[i]);
    }


-----------------------------------------------------
# Arrays(2)
# Häufigkeitszählung von Ziffern(2)

 * Arrays beginnen in C mit dem Index 0
  * Indexierung: ndigit[0]
 * Trick bei der Indexierung von ++ndigit[c-'0']
  * Datentyp char ist nur ein kleiner Integer
  * getchar() liefert [ASCII-Wert](http://en.wikipedia.org/wiki/ASCII) des Characters (48 fuer '0')
  * int und char sind arithmetisch vergleichbar
  * c-'0' gibt in unserem Fall immer einen Wert zw. 0..9

-----------------------------------------------------
# Funktionen(1)

Bisher nur integrierte Funktionen genutzt:

 * printf, getchar

Eigene Funktion:

    return-type function-name(parameter declarations, if any) {
      declarations
      statements
    }

-----------------------------------------------------
# Funktionen(2)

    #include <stdio.h>
    
    // function prototype
    int power(int m, int n);
    
    // test power function
    int main() {
      int i;
    
      for (i = 0; i < 10; i++)
        printf("%d %d %d\n", i, power(2, i), power(-3, i));
    
      // return value for the OS
      return 0;
    }
    
    // power: raise base to the n-th power; n >= 0
    int power(int base, int n) {
      int i, p;
    
      p = 1;
      for (i = 1; i <= n; i++)
        p = p * base;
      
      // return value for the calling function
      return p;
    }
functions\_1.c

-----------------------------------------------------
# Funktionen(3)

### Warum Funktionen?

 * Lesbarkeit
 * Wiederverwendbarkeit
 * Wartbarkeit

### Speziell in C

 * Funktionen können in beliebiger Reihenfolge deklariert und definiert werden
  * in einem oder mehreren Quelldateien
 * Variablen einer Funktion sind nur lokal sichtbar
 * **return** ist an jeder Stelle erlaubt
  * diesmal auch in main


-----------------------------------------------------
# Funktionen(4)

### Argumente

 * Call by value vs. Call by reference
 * Beispiel: Siehe power() in functions\_1.c
  * n ist eine temporaere Variable
 * Ausnahme: Arrays
  * Adresse zum Array wird übergeben

-----------------------------------------------------
# Funktionen(5)

### Call by reference (Arrays)

    #include <stdio.h>
    
    void add_one(int []);
    
    // Call by reference for arrays
    int main() {
      int digit[] = {1};
    
      printf("Before call: %d\n", digit[0]);
      add_one(digit);
      printf("After call: %d\n", digit[0]);
    }
    
    // tmp[] supposedly should be local, but is it?
    void add_one(int tmp[]) {
      tmp[0]++;
    }
call\_by\_reference.c

* Neu: type void
* Vergleiche mit call by value

-----------------------------------------------------
# Strings(1)

    #include <stdio.h>
    
    int main() {
      char str_1[] = "ab\n";
      char str_2[] = {'b', 'b', '\n', '\0'};
    
      printf("str_1: %s", str_1);
      printf("str_2: %s", str_2);
    
      printf("Equality test: %i\n", (str_1 == str_2));
      printf("Equality test: %i\n", strcmp(str_1, str_2));
    }
strings.c

-----------------------------------------------------
# Strings(2)


 * C kennt keinen Datentyp String
 * char Arrays werden als String Konstanten gehandhabt
   * '\0' terminiert
 * Hilfs-Funktionen
  * strcpy, strcmp, strlen, ...
 * printf formatter: %s

-----------------------------------------------------
# Operatoren

### Arithmetisch

 * +, -, *, /
 * Modulus % (nicht definiert für float, double)

### Relational und Logisch

 * > >= < <=
 * == !=

-----------------------------------------------------
# Datentypen Konversion

 * Operatoren mit Operanden unterschiedlichen Typs konvertieren automatisch in den generelleren Typ
  * 2 / 1.2f wird zu float
 * manuelle Konversion durch 'casting'
 <pre>
      int x = 2;
      float y = 3.0f;
      printf("%f\n", ((float)x/y));
 </pre>

-----------------------------------------------------
# Bitweise Operatoren für char, short, int und long

 * & bitweise AND
 * | bitweise Inklusiv-Oder
 * ^ bitweise Exclusiv-Oder
 * << links schieben
 * >> rechts schieben
 * ~ Komplement

Beispiel:

<pre>
   x << 2
</pre>

Ist äquivalent zur Multiplikation mit 4, da der Wert von x um zwei Positionen verschoben wird.

-----------------------------------------------------
# Bedingte Ausdrücke

    if (a > b) 
      z = a;
    else
      z = b;
Errechnet das Maximum von a und b.

Kürzer:

    z = ( a > b ) ? a : b;

Allgemein:

    expr1 ? expr2 : expr3


-----------------------------------------------------
# Tools
### Make(1)

    GCC=/usr/bin/gcc

    test: foo.o
            $(GCC) -o test foo.o bar.o

    foo.o: bar.o
            $(GCC) -c foo.c

    bar.o:
            $(GCC) -c bar.c

    clean:
            rm -f test foo.o bar.o core
Makefile

-----------------------------------------------------
# Tools
### Make(2)

 * Automatisierung von Arbeitsschritten
 * Auflösen von Abhängigkeiten
 * Kompilieren

Prinzip:

 * Definition von Targets und Abhängigkeiten
  * Befehl um, das Target zu kompilieren

-----------------------------------------------------
# Konstanten (1)

 * Integer Konstante: 123456
 * Long Konstante: 123456L
   * Demo Überläufe
 * Unsigned Konstante: 123456u
 * Unsigned Long Konstante: 123456ul
 * Notationen
   * Oktal: 0123456 (führende Null)
   * Hexadezimal: 0x123456
   * Oktale und hexadzimale Konstanten können ebenfalls unsigned und long sein
 * Zeichen Konstanten sind Integer
  * geschrieben in einfachen Anführungszeichen ('a')
  * Alternativ '\0122' und '\xhh'

-----------------------------------------------------
# Konstanten (2)
### Escape Sequences

    |------------|--------------|------------|--------------|
    | \a         | alert/bell   | \v         | vert. tab    | 
    | \b         | backspace    | \\         | backslash    | 
    | \f         | formfeed     | \'         | single quote | 
    | \n         | newline      | \"         | double quote | 
    | \r         | carriage ret | \000       | oktal num    | 
    | \t         | horiz. tab   | \xff       | hex num      | 
    |------------|--------------|------------|--------------|

Die Konstante '\0' hat den Wert 0.

-----------------------------------------------------
# Konstanten (3)
### Strings 

 * String Konstante: "Ich bin ein String"
 * "" (leerer String; Anführungszeichen sind nicht Teil des Strings)
 * "hallo " "hsz-t" äquivalent zu "hallo hsz-t"
  * Strings können zur Kompilierzeit konkateniert werden
  * Sinnvoll, um lange Zeilen umzubrechen
 * String Funktionen definiert in string.h
  * man 3 string
  * /usr/include
 * 'x' ungleich "x" (Integer vs. Zeichen-Array + '\0')

-----------------------------------------------------
# Konstanten (4)
### Enumeration 

    enum boolean { NO, YES };

Der erste Wert eines enum hat den Wert 0, der nächste 1 und so weiter - es sei
denn es werden explizite Werte definiert.

   enum escapes { BELL = '\a', BACKSPACE = '\b' };

Namen in unterschiedlichen enumerations müssen eindeutig sein. Die Werte
innerhalb eines enums müssen nicht eindeutig sein.

Enumerations bieten eine komfortablen Möglichkeit, um Konstanten mit Namen zu
definieren - eine gute Alternative zu #define. Variablen in Enumerations haben

* Vorteile enum vs. #define:
 * Variable können vom Compiler geprüft zu werden
 * Debugger können symbolische Konstanten anzeigen

-----------------------------------------------------
# Deklaration

* Variablen müssen vor Nutzen deklariert werden
* einige Deklarationen können implizit durch den Inhalt bestimmt werden
* Deklarationen spezifizieren Typ und einen oder mehrere Variablennamen
* Variablen können bei Deklaration initialisiert werden
* Variablen in Blöcken und Funktionen können mit Ausdrücken initialsiert werden
* Kennzeichner 'const' bei Deklaration


-----------------------------------------------------
# Kontrollfluss (1)
### If-Else (1)

Formale Syntax:

    if (expression)
      statement_1
    else
      statement_2

Äquivalent

    if (expression)
    if (expression != 0)

-----------------------------------------------------
# Kontrollfluss (2)
### If-Else (2)

Assoziation
    
    if (n > 0)
      if (a > b)
        z = a;
      else
        z = b;

    vs

    if (n > 0) {
      if (a > b)
        z = a;
    } else
      z = b;


-----------------------------------------------------
# Kontrollfluss (3)
### Else-If

    if (expression)
      statement
    else if (expression)
      statement
    else if (expression)
      statement
    else
      statement

* 'else' ist optional. Kann genutzt werden, um generellen Fehler zu beschreiben.


-----------------------------------------------------
# Kontrollfluss (4)
### Switch(1)

    switch (expression) {
      case const-expr: statements
      case const-expr: statements
      default: statements
    }

* 'case' Label enthalten Integer Konstanten
* 'default' Label wird ausgeführt falls keine andere Bedingung zutrifft
  * 'default' ist optional
* Evaluation von statements unter case wird mit 'break' beendet


Altes Beispiel - Zählen von Ziffern:

    switch (c) {
     case '0': case '1': case '2':
       ndigit[c-'0']++;
       break;
     case ' ':
     case '\n':
     case '\t':
       white_space_count++
       break;
     }
       
-----------------------------------------------------
# Kontrollfluss (5)
### Switch(2)

* 'break' beendet 'switch' 
* 'case' ist nur ein Label. Verarbeitung läuft ohne explizite Aktion diese zu
  verlassen weiter und fällt in das nächste 'case' Statement.
  * Hierauf immer achten! Vor allem bei Ändern von bestehendem Code.
* 'break' wird ebenso in 'while' 'for' und 'do' Schleifen genutzt
* Guter Stil: 'break' nach letztem Label - syntaktisch aber nicht notwendig
  * Stichwort: Defensives Programmieren

    
-----------------------------------------------------
# Kontrollfluss (6)
### While und For (1)

While Syntax:

    while (expression)
      statement

For Syntax:

    for (expr_1; expr_2; expr_3)
      statement

äquivalent zu:

    expr_1;
    while (expr_2) {
       statement
       expr_3;
    }
    
-----------------------------------------------------
# Kontrollfluss (7)
### While und For (2)

* For: jeder der drei Ausdrücke ist optional

####'Infinite Loop'

* kann durch 'break' oder 'return' beendet werden
* garantiert die Ausführung der Ausdrücke von links nach rechts
<pre>
   for (;;) {}
</pre>

-----------------------------------------------------
# Kontrollfluss (8)
### Komma-Operator

* meist genutzt in 'for' Schleifen
 * sind insgesamt aber selten zu finden

<pre>
#include <string.h>

/* reverse: reverse string s in place */ 
void reverse(char s[]) {
  int c, i, j;
  for (i = 0, j = strlen(s)-1; i < j; i++, j--) { 
    c = s[i];
    s[i] = s[j]; 
    s[j] = c;
  }
}
</pre>
reverse.c

-----------------------------------------------------
# Kontrollfluss (9)
### Do-While

* Seltener genutzt als 'for' und 'while'
* Führt Block mindestens einmal aus

<pre>
do
  statement
while (expression);
</pre>

-----------------------------------------------------
# Kontrollfluss (10)
### Break und Continue

* 'break' 
 * beendet die innerste Schleife in 'for', 'while', 'do' und 'switch'
* 'continue' 
 * ist verwandt, wird aber weniger genutzt
 * beendet die Ausführung der innersten Schleife und startet nächste Iteration
 * funktioniert nur in Schleifen, nicht in 'switch'

<pre>
for (i = 0; i < n; i++) 
  /* skip negative elements */
  if (a[i] < 0)   
    continue; 
  ... /* do positive elements */
</pre>


-----------------------------------------------------
# Kontrollfluss (11)
### Goto und Label
















-----------------------------------------------------
# Exec 

    #include <stdio.h>
    #include <unistd.h>

    int main(void) {
      execl("/bin/echo", "echo", "Hello, World!", NULL);
    }
exec.c

-----------------------------------------------------
# Fork

    #include <stdio.h>
    #include <unistd.h>

    int main(void) {
      pid_t ret_f = fork();
      pid_t pid   = getpid();
      printf("%i: return value of fork was %i\n", pid, ret_f);
      if (ret_f > 0) {
        waitpid(ret_f);
      }
      printf("%i: program end\n", pid, ret_f);
    }
fork.c

-----------------------------------------------------
# Signal

    #include <signal.h>
    #include <stdio.h>
    #include <stdlib.h>

    void signal_handler() {
      printf(" time's up!\n");
      exit(0);
    }

    int main() {
      struct sigaction sa;
      sa.sa_handler = signal_handler;
      sigemptyset(&sa.sa_mask);
      sa.sa_flags = 0;
      sigaction(SIGALRM, &sa, NULL);
      alarm(5);
      while(1) {
        printf(".");
        fflush(stdout);
        sleep(1);
      }
    }
signal.c

-----------------------------------------------------
# Socket

    /* sends a string via udp.
     * a valid listener is netcat:
     * netcat -lup 4000
     */

    #include <sys/socket.h>
    #include <sys/types.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <netinet/ip.h>


    int main(void)
    {
      char *msg = "Hello, World!\n";
      int sock = socket(AF_INET, SOCK_DGRAM, 0);
      struct sockaddr_in server;
      server.sin_family = AF_INET;
      server.sin_port   = htons(4000);
      server.sin_addr.s_addr = inet_addr("127.0.0.1");
      sendto(sock, msg, strlen(msg)+1, 0, (struct sockaddr*)&server,
             sizeof(server));
      close(sock);
      exit(0);
    }
socket.c

-----------------------------------------------------
# Wait

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/wait.h>

    int main(void) {
      pid_t ret_f = fork();
      if (0 == ret_f) {
        exit(-1);
      }
      int status;
      wait(&status);
      status = WEXITSTATUS(status);
      printf("child exit status: %i\n", status);
      exit(-1);
    }
wait.c






-->
</script>
<script>
var scripts = document.getElementsByTagName('script');
for (var i = 0; i < scripts.length; i++){
    var script = scripts[i];
    if (script.type != 'text/markdown') continue;
    var md = script.innerHTML.replace(/^\s<!--*/, '')
        .replace(/-->\s*$/, '');
    var markup = new Showdown.converter().makeHtml(md);
    var slides = markup.split('<hr />');
    for (var j = 0; j < slides.length; j++)
        document.write('<div class=slide>' + slides[j] + '</div>');
}
w3c_slidy.add_listener(document.body, "touchend", w3c_slidy.mouse_button_click);
</script>
</body>
</html>
